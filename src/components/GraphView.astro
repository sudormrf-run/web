---
/**
 * GraphView Component
 * Obsidian-style force-directed graph visualization
 * Reusable across pages with different modes
 *
 * Usage:
 * - mode='navigate': Click navigates to document page (default, for embedding)
 * - mode='select': Click emits event for parent to handle (for browse page)
 *
 * Events (when mode='select'):
 * - graph:node-select: { node, connectedNodes }
 * - graph:node-hover: { node, connectedNodes }
 */

export interface GraphNode {
  id: string;
  type: 'document' | 'tag';
  label: string;
  category?: string;
  color?: string;
  url?: string;
  val?: number;
  description?: string;
  tags?: string[];
}

export interface GraphLink {
  source: string;
  target: string;
  type?: 'tag' | 'related';
}

export interface Props {
  graphData: {
    nodes: GraphNode[];
    links: GraphLink[];
  };
  height?: string;
  locale?: 'ko' | 'en';
  mode?: 'navigate' | 'select';
  showLegend?: boolean;
  showControls?: boolean;
  selectedNodeId?: string;
  controlsAccent?: 'orange' | 'green' | 'blue';
}

const {
  graphData,
  height = '500px',
  locale = 'ko',
  mode = 'navigate',
  showLegend = true,
  showControls = true,
  selectedNodeId = null,
  controlsAccent = 'orange',
} = Astro.props;

// Accent colors for controls
const accentColors = {
  orange: '#fd7318',
  green: '#43d6a8',
  blue: '#5fadfe',
};

// Generate unique ID for this instance
const instanceId = `graph-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="graph-container" id={instanceId} style={`height: ${height}; --controls-accent: ${accentColors[controlsAccent]}`} data-mode={mode}>
  <div class="graph-controls">
    {showLegend && (
      <div class="graph-legend">
        <span class="legend-item">
          <span class="legend-dot" style="background: #eab308"></span>
          {locale === 'ko' ? '에세이' : 'Essays'}
        </span>
        <span class="legend-item">
          <span class="legend-dot" style="background: #3b82f6"></span>
          {locale === 'ko' ? '모델' : 'Models'}
        </span>
        <span class="legend-item">
          <span class="legend-dot" style="background: #10b981"></span>
          {locale === 'ko' ? '기업' : 'Companies'}
        </span>
        <span class="legend-item">
          <span class="legend-dot" style="background: #a78bfa"></span>
          {locale === 'ko' ? '하드웨어' : 'Hardware'}
        </span>
        <span class="legend-item">
          <span class="legend-dot" style="background: #f472b6"></span>
          {locale === 'ko' ? '인물' : 'People'}
        </span>
      </div>
    )}
    {!showLegend && <div></div>}
    {showControls && (
      <div class="graph-actions">
        <button class="graph-btn zoom-in" title="Zoom In">+</button>
        <button class="graph-btn zoom-out" title="Zoom Out">-</button>
        <button class="graph-btn reset-view" title="Reset View">
          <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
          </svg>
        </button>
      </div>
    )}
  </div>
  <div class="graph-canvas"></div>
  <div class="graph-tooltip"></div>
</div>

<script define:vars={{ graphData, instanceId, mode, selectedNodeId, locale }}>
  // Initialize graph after DOM is ready
  async function initGraph() {
    const ForceGraph = (await import('https://esm.sh/force-graph@1.43.5')).default;
    const d3 = await import('https://esm.sh/d3-force@3');

    const root = document.getElementById(instanceId);
    if (!root) return;

    const container = root.querySelector('.graph-canvas');
    const tooltip = root.querySelector('.graph-tooltip');

    if (!container) return;

    // Get container dimensions
    const width = container.clientWidth;
    const height = container.clientHeight;

    // Track state
    let hoveredNode = null;
    let selectedNode = null;
    let connectedNodes = new Set();
    let filterHighlightedNodes = new Set(); // Nodes matching filter (empty = all highlighted)

    // Find node by ID
    const findNodeById = (id) => graphData.nodes.find(n => n.id === id);

    // Get connected node IDs for a given node
    const getConnectedNodeIds = (nodeId) => {
      const connected = new Set([nodeId]);
      graphData.links.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
        if (sourceId === nodeId) connected.add(targetId);
        if (targetId === nodeId) connected.add(sourceId);
      });
      return connected;
    };

    // Emit custom event
    const emitEvent = (eventName, node) => {
      if (!node) {
        root.dispatchEvent(new CustomEvent(eventName, {
          detail: { node: null, connectedNodes: [] },
          bubbles: true
        }));
        return;
      }

      const connected = getConnectedNodeIds(node.id);
      const connectedNodeData = Array.from(connected)
        .map(id => findNodeById(id))
        .filter(Boolean);

      root.dispatchEvent(new CustomEvent(eventName, {
        detail: {
          node: { ...node },
          connectedNodes: connectedNodeData
        },
        bubbles: true
      }));
    };

    // Create the graph
    const graph = ForceGraph()(container)
      .graphData(graphData)
      .width(width)
      .height(height)
      .backgroundColor('transparent')
      .nodeLabel(() => '') // We use custom tooltip
      .nodeVal(node => node.val || 3)
      .nodeRelSize(3)
      .linkWidth(link => {
        const activeNode = hoveredNode || selectedNode;
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;

        // Check if link connects highlighted nodes (filter)
        const hasFilter = filterHighlightedNodes.size > 0;
        const bothInFilter = !hasFilter || (filterHighlightedNodes.has(sourceId) && filterHighlightedNodes.has(targetId));

        if (activeNode) {
          return (sourceId === activeNode.id || targetId === activeNode.id) ? 2 : (bothInFilter ? 0.5 : 0.2);
        }
        return bothInFilter ? 1 : 0.3;
      })
      .linkColor(link => {
        const activeNode = hoveredNode || selectedNode;
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;

        // Check if link connects highlighted nodes (filter)
        const hasFilter = filterHighlightedNodes.size > 0;
        const bothInFilter = !hasFilter || (filterHighlightedNodes.has(sourceId) && filterHighlightedNodes.has(targetId));

        if (activeNode) {
          if (sourceId === activeNode.id || targetId === activeNode.id) {
            return 'rgba(255, 255, 255, 0.6)';
          }
          return bothInFilter ? 'rgba(107, 114, 128, 0.15)' : 'rgba(107, 114, 128, 0.05)';
        }
        return bothInFilter ? 'rgba(107, 114, 128, 0.3)' : 'rgba(107, 114, 128, 0.08)';
      })
      // Force simulation - essays as local centers
      .d3AlphaDecay(0.015)
      .d3VelocityDecay(0.35)
      .d3Force('charge', d3.forceManyBody()
        .strength(node => node.category === 'essays' ? -100 : -50)
        .distanceMax(200))
      .d3Force('link', d3.forceLink().distance(50).strength(0.7))
      .d3Force('center', d3.forceCenter().strength(0.05))
      .d3Force('collision', d3.forceCollide().radius(node => (node.val || 3) + 4))
      .d3Force('x', d3.forceX().strength(0.02))
      .d3Force('y', d3.forceY().strength(0.02))
      .warmupTicks(300)
      .cooldownTicks(400)
      .onNodeHover(node => {
        container.style.cursor = node ? 'pointer' : 'default';
        hoveredNode = node;

        // Update connected nodes
        connectedNodes.clear();
        if (node) {
          connectedNodes = getConnectedNodeIds(node.id);

          const connectionText = locale === 'ko'
            ? `${connectedNodes.size - 1}개 연결`
            : `${connectedNodes.size - 1} connections`;

          tooltip.innerHTML = `
            <div class="tooltip-title">${node.label}</div>
            <div class="tooltip-type">${node.category || 'Document'}</div>
            <div class="tooltip-connections">${connectionText}</div>
          `;
          tooltip.style.display = 'block';
        } else {
          tooltip.style.display = 'none';
        }

        // Emit hover event (for panel preview)
        if (mode === 'select') {
          emitEvent('graph:node-hover', node);
        }

        // Trigger re-render for highlighting
        graph.nodeColor(graph.nodeColor());
      })
      .onNodeClick(node => {
        if (mode === 'navigate') {
          // Direct navigation mode
          if (node.url) {
            window.location.href = node.url;
          }
        } else {
          // Select mode - emit event for parent to handle
          selectedNode = node;
          connectedNodes = getConnectedNodeIds(node.id);
          emitEvent('graph:node-select', node);

          // Center on node
          graph.centerAt(node.x, node.y, 400);
          graph.zoom(2, 400);

          // Trigger re-render
          graph.nodeColor(graph.nodeColor());
        }
      })
      .onNodeDragEnd(node => {
        node.fx = node.x;
        node.fy = node.y;
      });

    // Draw custom node shapes
    graph.nodeCanvasObject((node, ctx, globalScale) => {
      const size = node.val || 4;
      const fontSize = Math.max(10 / globalScale, 3);

      // Determine highlight state
      const activeNode = hoveredNode || selectedNode;
      const hasFilter = filterHighlightedNodes.size > 0;
      const isFilterHighlighted = !hasFilter || filterHighlightedNodes.has(node.id);
      const isHoverHighlighted = !activeNode || connectedNodes.has(node.id);
      const isHighlighted = isFilterHighlighted && isHoverHighlighted;
      const isActive = activeNode && activeNode.id === node.id;

      // Combine filter and hover dimming
      let opacity = 1;
      if (!isFilterHighlighted) opacity = 0.15;
      else if (activeNode && !isHoverHighlighted) opacity = 0.2;

      // Draw filled circle
      ctx.beginPath();
      ctx.arc(node.x, node.y, isActive ? size * 1.3 : size, 0, 2 * Math.PI);
      ctx.fillStyle = node.color || '#6b7280';
      ctx.globalAlpha = opacity;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Draw border for active node
      if (isActive) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2 / globalScale;
        ctx.stroke();
      }

      // Draw label if zoomed in enough or if active/connected
      if (globalScale > 0.8 || isActive || (activeNode && connectedNodes.has(node.id))) {
        ctx.font = `${isActive ? fontSize * 1.2 : fontSize}px Pretendard, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = isHighlighted ? '#e5e5e5' : 'rgba(229, 229, 229, 0.3)';

        const label = node.label.length > 25
          ? node.label.substring(0, 23) + '...'
          : node.label;
        ctx.fillText(label, node.x, node.y + (isActive ? size * 1.3 : size) + 2);
      }
    });

    // Zoom controls
    root.querySelector('.zoom-in')?.addEventListener('click', () => {
      graph.zoom(graph.zoom() * 1.5, 400);
    });

    root.querySelector('.zoom-out')?.addEventListener('click', () => {
      graph.zoom(graph.zoom() / 1.5, 400);
    });

    root.querySelector('.reset-view')?.addEventListener('click', () => {
      selectedNode = null;
      connectedNodes.clear();
      graph.zoomToFit(400, 50);
      graph.nodeColor(graph.nodeColor());
      if (mode === 'select') {
        emitEvent('graph:node-select', null);
      }
    });

    // Handle resize
    const resizeObserver = new ResizeObserver(() => {
      graph.width(container.clientWidth);
      graph.height(container.clientHeight);
    });
    resizeObserver.observe(container);

    // Initial zoom to fit
    setTimeout(() => {
      graph.zoomToFit(400, 50);
    }, 500);

    // Track mouse for tooltip positioning
    container.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      tooltip.style.left = `${e.clientX - rect.left + 15}px`;
      tooltip.style.top = `${e.clientY - rect.top + 15}px`;
    });

    // Expose methods for external control
    root._graphInstance = {
      focusNode: (nodeId) => {
        const node = findNodeById(nodeId);
        if (node) {
          selectedNode = node;
          connectedNodes = getConnectedNodeIds(node.id);
          graph.centerAt(node.x, node.y, 400);
          graph.zoom(2, 400);
          graph.nodeColor(graph.nodeColor());
        }
      },
      resetView: () => {
        selectedNode = null;
        connectedNodes.clear();
        graph.zoomToFit(400, 50);
        graph.nodeColor(graph.nodeColor());
      },
      updateData: (newData) => {
        graph.graphData(newData);
      },
      // Set nodes to highlight (dim others). Pass empty set to clear filter.
      setFilterHighlight: (nodeIds) => {
        filterHighlightedNodes = new Set(nodeIds);
        graph.nodeColor(graph.nodeColor()); // Trigger re-render
      },
      clearFilterHighlight: () => {
        filterHighlightedNodes.clear();
        graph.nodeColor(graph.nodeColor()); // Trigger re-render
      }
    };
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGraph);
  } else {
    initGraph();
  }
</script>

<style>
  .graph-container {
    position: relative;
    width: 100%;
    background: var(--color-bg-secondary, #111);
    border: 1px solid var(--color-border, #333);
    border-radius: var(--radius-lg, 12px);
    overflow: hidden;
  }

  .graph-controls {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    background: linear-gradient(to bottom, rgba(10, 10, 15, 0.9), transparent);
    z-index: 10;
  }

  .graph-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    font-size: 0.7rem;
    color: var(--color-text-muted, #888);
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  .legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
  }

  .graph-actions {
    display: flex;
    gap: 0.5rem;
  }

  .graph-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    background: var(--color-bg-primary, #0a0a0f);
    border: 1px solid rgba(95, 173, 254, 0.3);
    border-color: color-mix(in srgb, var(--controls-accent, #fd7318) 40%, transparent);
    border-radius: var(--radius-sm, 6px);
    color: var(--color-text-secondary, #aaa);
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.15s;
  }

  .graph-btn:hover {
    background: var(--color-bg-secondary, #1a1a1f);
    color: var(--controls-accent, #fd7318);
    border-color: var(--controls-accent, #fd7318);
  }

  .graph-canvas {
    width: 100%;
    height: 100%;
  }

  .graph-tooltip {
    position: absolute;
    display: none;
    padding: 0.5rem 0.75rem;
    background: var(--color-bg-primary, #0a0a0f);
    border: 1px solid var(--color-border, #333);
    border-radius: var(--radius-sm, 6px);
    font-size: 0.8rem;
    pointer-events: none;
    z-index: 100;
    max-width: 200px;
  }

  .tooltip-title {
    color: var(--color-text-primary, #fff);
    font-weight: 600;
    margin-bottom: 0.25rem;
  }

  .tooltip-type {
    color: var(--color-text-muted, #888);
    font-size: 0.7rem;
    text-transform: capitalize;
  }

  .tooltip-connections {
    color: var(--color-accent, #3b82f6);
    font-size: 0.7rem;
    margin-top: 0.25rem;
  }

  @media (max-width: 640px) {
    .graph-legend {
      display: none;
    }

    .graph-controls {
      justify-content: flex-end;
    }
  }
</style>
